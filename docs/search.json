[
  {
    "objectID": "pages/data_processing.html",
    "href": "pages/data_processing.html",
    "title": "Data Processing & Investigation",
    "section": "",
    "text": "This notebook contains several functions that will allow users to query the Census API with their own inputs, and then explore the data through summary statistics.\n\nImport necessary libraries\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(stringr)\nlibrary(purrr)\nlibrary(ggplot2)\n\n\n\nHelper functions\n\nHelper function to convert API request results to tibble\n\nto_tibble &lt;- function(request) {\n  req &lt;- fromJSON(rawToChar(request$content))\n\n  # get data rows\n  data_rows &lt;- req[-1, ]\n  # create tibble\n  data &lt;- as_tibble(data_rows)\n  \n  # Assign column names to data\n  col_names &lt;- req[1, ]\n  colnames(data) &lt;- col_names \n  \n  # Return tibble\n  return(data)\n}\n\n\n\nHelper function to parse and convert time values\n\nparse_time &lt;- function(time_string) {\n  ts &lt;- as.character(time_string)\n  if (length(ts) == 0 || is.na(ts) || ts == \"\") return(NA)\n  \n  # split start and end\n  parts &lt;- str_split(ts, \" to \", simplify = TRUE)\n  \n  # Replace a.m/p.m with AM/PM to work with POSIXct\n  start_clean &lt;- toupper(sub(\"p.m.\", \"PM\", sub(\"a.m.\", \"AM\", parts[1])))\n  end_clean   &lt;- toupper(sub(\"p.m.\", \"PM\", sub(\"a.m.\", \"AM\", parts[2])))\n  \n  # find start and end times\n  start &lt;- as.POSIXct(start_clean, format = \"%I:%M %p\", tz = \"UTC\")\n  end   &lt;- as.POSIXct(end_clean,   format = \"%I:%M %p\", tz = \"UTC\")\n  \n  # find midpoint between start and end times\n  mid &lt;- start + difftime(end, start, units = \"secs\") / 2\n  \n  # format as HH:MM\n  format(mid, \"%I:%M %p\")\n}\n\n\n\nHelper function to map JWAP and JWDP time codes to actual times\n\ntime_code_lookup &lt;- function(data, var, year, parse_fun) {\n  if (var %in% names(data)) {\n    # get metadata and decode codes to value strings\n    meta &lt;- fromJSON(paste0(\"https://api.census.gov/data/\", \n                            year, \"/acs/acs1/pums/variables/\",\n                            var, \".json\"))\n    \n    # extract codes\n    lookup &lt;- meta$values$item\n\n    # r removes leading zeros from codes, so add them back to match lookup keys (3 digits)\n    padded_codes &lt;- str_pad(data[[var]], width = 3, side = \"left\", pad = \"0\")\n    data[[var]] &lt;- lookup[padded_codes]\n\n    # parse value strings\n    data[[var]] &lt;- sapply(data[[var]], parse_fun)\n  }\n  return(data)\n}\n\n\n\n\nFunction to query the census API with user input\n\nquery_pums &lt;- function(\n    year = 2022,\n    num_vars = c('AGEP', 'PWGTP'),\n    cat_vars = 'SEX',\n    geo_level = 'State',\n    subset = '18'\n) {\n  \n  # Stop if year is not between 2010 and 2022\n  if (!year %in% 2010:2022)\n    stop('Year must be between 2010 and 2022.')\n  \n  # stop if year = 2020\n  if (year == 2020)\n    stop('No data available for 2020.')\n  \n  # Define valid numeric variables\n  valid_num &lt;- c('AGEP', 'PWGTP', 'GASP', 'GRPIP', 'JWAP', 'JWDP', 'JWMNP')\n  \n  # Stop if num_vars input is valid\n  if (!all(num_vars %in% valid_num))\n    stop('Invalid input for numeric variables.')\n  # Stop if PWGTP is not returned\n  if (!'PWGTP' %in% num_vars)\n    stop('PWGTP must be returned.')\n  # Stop if less than 2 numeric variables are returned\n  if (length(num_vars) &lt; 2)\n    stop('At least one numeric variable aside from PWGTP must be returned.')\n  \n  # Define valid categorical variables\n  valid_cat &lt;- c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX')\n  \n  # Stop if cat_vars input is invalid\n  if (!all(cat_vars %in% valid_cat))\n    stop('Invalid input for categorical variables.')\n  # Stop if no categorical variables are returned\n  if (length(cat_vars) &lt; 1)\n    stop('At least one categorical variable must be returned.')\n  \n  # Define valid inputs for geography\n  valid_geo &lt;- c('All', 'Region', 'Division', 'State')\n  \n  # Stop if geo_level input is not valid\n  if (!geo_level %in% valid_geo)\n    stop('Invalid input for geography level.')\n  \n  # Base URL\n  url &lt;- 'https://api.census.gov/data'\n  # Data set we want to query\n  dataset &lt;- 'acs/acs1/pums'\n  # Variables to query\n  vars &lt;- c(num_vars, cat_vars)\n  \n  # Build URL with user inputs\n  api_url &lt;- paste0(\n    url, \"/\", year, \"/\", dataset,\n    \"?get=\", paste(vars, collapse = \",\")\n  )\n  \n  # Geography level subsetting\n  geo_map &lt;- c(\n    Region   = \"region:*\",\n    Division = \"division:*\",\n    State    = \"state:*\"\n  )\n  \n  # allow users to specify subsets of geography level\n  if (!is.null(subset)) {\n    if (geo_level == 'State') {\n      api_url &lt;- paste0(api_url, '&for=state:', paste(subset, collapse = ','))\n    }\n    if (geo_level == 'Region') {\n      api_url &lt;- paste0(api_url, '&for=region:', paste(subset, collapse = ','))\n    }\n    if (geo_level == 'Division') {\n      api_url &lt;- paste0(api_url, '&for=division:', paste(subset, collapse = ','))\n    }\n  } else if (geo_level != 'All') {\n    api_url &lt;- paste0(api_url, '&for=', geo_map[[geo_level]])\n  }\n  \n  # Query the API\n  request &lt;- GET(api_url)\n  \n  # Call helper function to turn query results into tibble\n  data &lt;- to_tibble(request)\n  \n  # Convert categorical variables to factors\n  for (var in cat_vars) {\n    if (var %in% names(data)) {\n      data[[var]] &lt;- as.factor(data[[var]])\n    }\n  }\n  \n  # Ensure numeric variables are the correct type\n  for (var in num_vars) {\n    if (var %in% names(data)) {\n      data[[var]] &lt;- as.numeric(data[[var]])\n    }\n  }\n  \n  # Parse time variables if included in query\n  data &lt;- time_code_lookup(data, \"JWDP\", year, parse_time)\n  data &lt;- time_code_lookup(data, \"JWAP\", year, parse_time)\n  \n  # For summary function\n  class(data) &lt;- c(\"census\", class(data))\n  \n  return(data)\n}\n\n\n\nTest query_pums() function\nWithout sub-setting the geography level, this function is time consuming to run.\n\nquery_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP', 'JWAP'),\n  cat_vars = c('SEX', 'HISPEED'),\n  geo_level = 'State',\n  subset='18'\n)\n\n# A tibble: 69,843 × 6\n    AGEP PWGTP JWAP     SEX   HISPEED state\n   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    &lt;fct&gt; &lt;fct&gt;   &lt;chr&gt;\n 1    18    61 02:12 PM 2     0       18   \n 2    69    83 &lt;NA&gt;     2     0       18   \n 3    19    73 &lt;NA&gt;     1     0       18   \n 4    18    65 &lt;NA&gt;     2     0       18   \n 5    64    90 &lt;NA&gt;     2     0       18   \n 6    45    71 &lt;NA&gt;     2     0       18   \n 7    19    55 &lt;NA&gt;     1     0       18   \n 8    20    64 07:52 PM 2     0       18   \n 9    20    24 02:32 PM 1     0       18   \n10    94    11 &lt;NA&gt;     2     0       18   \n# ℹ 69,833 more rows\n\n\nVerify that checks work correctly (commented out after testing so document can be rendered) Calling Function with invalid year (outside of valid range):\n\n#query_pums(year = 2008)\n\nCalling function with invalid year (2020):\n\n#query_pums(year = 2020)\n\nCalling function without ‘PWGTP’ variable:\n\n#query_pums(year = 2022, num_vars = c('AGEP', 'JWAP'))\n\nCalling function without any categorical variables:\n\n#query_pums(year = 2022, cat_vars = NULL)\n\n\n\nAdd function to specify multiple years of survey data\n\nquery_pums_multi &lt;- function(\n  years,\n  num_vars = c(\"AGEP\", \"PWGTP\"),\n  cat_vars = \"SEX\",\n  geo_level = \"State\",\n  subset = '18'\n) {\n  # stop if year input is invalid\n  if (!all(years %in% 2010:2022))\n    stop(\"Please enter years that are between 2010 and 2022.\")\n  \n  # stop if year = 2020\n  if (any(years == 2020))\n    stop('No data available for 2020.')\n\n  # query each specified year of survey data\n  map_dfr(\n    years,\n    ~ {\n      dat &lt;- query_pums(\n        year = .x,\n        num_vars = num_vars,\n        cat_vars = cat_vars,\n        geo_level = geo_level, \n        subset = subset\n        )\n      dat$year &lt;- .x\n      return(dat)\n      }\n  )\n}\n\n\n\nTest query_pums_multi() function\n\ndata &lt;- query_pums_multi(\n  years = c(2019, 2021, 2022),\n  num_vars = c('AGEP', 'PWGTP', 'JWAP'),\n  cat_vars = c('SEX', 'FER'),\n  geo_level = 'State',\n  subset='18'\n)\n\n# check that all requested years are included in result\ndata |&gt; count(year)\n\n# A tibble: 3 × 2\n   year     n\n  &lt;dbl&gt; &lt;int&gt;\n1  2019 67445\n2  2021 68122\n3  2022 69843\n\n\nVerify that checks for invalid years work (commented out after testing so document can be rendered) Calling function with year = 2020\n\n#query_pums_multi(years = c(2019, 2020))\n\nCalling function with years outside of 2010-2022 range\n\n#query_pums_multi(years = c(2008, 2009))\n\n\n\nFunction for Summarizing\n\nsummary.census &lt;- function(\n    tibble = tibble,\n    num_vars = NULL,\n    cat_vars = NULL\n) {\n  \n  # if no numeric variables are specified, select all except PWGTP\n  if (is.null(num_vars)) {\n    num_vars &lt;- tibble |&gt;\n      # select numeric variables\n      select(where(is.numeric)) |&gt;\n      # exclude PWGTP\n      select(-PWGTP) |&gt;\n      names()\n  }\n  \n  # if no categorical variables are specified, select all\n  if (is.null(cat_vars)) {\n    cat_vars &lt;- tibble |&gt;\n      select(where(is.factor)) |&gt;\n      names()\n  }\n  \n  # use PWGTP as weight\n  weight &lt;- tibble$PWGTP\n  \n  # numeric variables summary\n  numeric &lt;- sapply(num_vars, function(v) {\n    x &lt;- tibble[[v]]\n    # calculate weighted mean and SD\n    mean &lt;- sum(x * weight, na.rm = TRUE)/sum(weight)\n    sd &lt;- sqrt(sum(x^2*weight, na.rm = TRUE)/sum(weight)-mean^2)\n    # create vector of values\n    c(mean = mean, sd = sd)\n  })\n  \n  categorical &lt;- lapply(cat_vars, function(v) {\n    tibble |&gt;\n      group_by(.data[[v]]) |&gt;\n      summarise(count = sum(weight, na.rm = TRUE))\n  })\n  \n  return(list(num_summary = numeric, cat_summary = categorical))\n}\n\n\n\nTest summary function\n\ncensus &lt;- query_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP', 'GASP'),\n  cat_vars = c('SEX', 'HISPEED'),\n)\n\nsummary(census)\n\n$num_summary\n         AGEP      GASP\nmean 38.92552  83.29869\nsd   23.40716 178.11080\n\n$cat_summary\n$cat_summary[[1]]\n# A tibble: 2 × 2\n  SEX     count\n  &lt;fct&gt;   &lt;dbl&gt;\n1 1     6833037\n2 2     6833037\n\n$cat_summary[[2]]\n# A tibble: 3 × 2\n  HISPEED   count\n  &lt;fct&gt;     &lt;dbl&gt;\n1 0       6833037\n2 1       6833037\n3 2       6833037\n\n\n\n\nFunction to plot census data\n\nplot_census &lt;- function(tibble, cat_var, num_var) {\n  ggplot(tibble,\n         aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +\n    geom_boxplot() +\n    # Add axis labels\n    labs(x = cat_var, y = num_var)\n}\n\n\n\nTest plot function\n\nplot_census(census, cat_var = 'SEX', num_var = 'AGEP')\n\n\n\n\n\n\n\n\n\n\nData investigation\nQuery API:\n\ndata &lt;- query_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP', 'JWAP', 'JWDP', 'GASP', 'GRPIP', 'JWMNP'),\n  cat_vars = c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX'),\n  geo_level = 'State',\n  subset='37'\n)\n\nPlot of mode of transportation to work VS travel time to work:\nDiscussion:\n\nMost of the boxplots have little to no lower tail and are right skewed (meaning more longer commute times than shorter)\nCar (1), walking (10), other (12), bus (2), taxi (7), bicycle (9) all have outliers around the same spot, just below 150 minutes\nLong-distance train or commuter rail (4) has no tails on either end of the box, and looks to have no upper quartile after the median.\nCommute time by car (1) has many outliers between 50-100 minutes, and has the most outliers out of any mode of transportation.\nWalking and biking have shorter commute times than I anticipated, especially compared to cars.\nTransportation mode = 6 is ferryboat, which is interesting that enough people commute to work by ferry for it to have its own category outside of ‘other’\n\nJWTRNS = 0, 11: NA, worked from home\n\nplot_census(data, cat_var = 'JWTRNS', num_var = 'JWMNP')",
    "crumbs": [
      "Home",
      "Data Processing & Investigation"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Index",
    "section": "",
    "text": "Overview: Description of workflow and functions\nData Processing: Functions to query API and summarize data",
    "crumbs": [
      "Home",
      "Index"
    ]
  },
  {
    "objectID": "index.html#project-goal",
    "href": "index.html#project-goal",
    "title": "Index",
    "section": "Project Goal",
    "text": "Project Goal\nThe goal of this project is to write functions that will manipulate and process data sets that come from a census API. We have created generic functions to automatically summarize and plot certain returned data.",
    "crumbs": [
      "Home",
      "Index"
    ]
  },
  {
    "objectID": "pages/narrative.html",
    "href": "pages/narrative.html",
    "title": "Narrative",
    "section": "",
    "text": "Tibble helper function:\n\nThis function takes the API request built in query_pums() and turns it into a tibble.\nExample usage:\n# after building API URL, use GET()\napi_request &lt;- GET(api_url)\n\n# Call helper function to turn query results into tibble\ndata &lt;- to_tibble(request)\n\nParse times helper function:\n\nThis function takes a string containing a range of times and returns the midpoint of those two times.\nExample: given “12:30p.m to 12:34p.m”, parse_times() will return “12:42p.m”\n\nCode look-up helper function:\n\nThis function uses the Census API variable information to look up the times associated with a given code for the JWAP and JWDP variables.\nThe function uses the year specified in query_pums() to access the variable metadata.\nThe parse_times() function is applied after looking up the codes.\nExample: given “258” for the variable “JWAP”, code_lookup() will return the string “9:40 p.m. to 9:44 p.m.”\n\n\n\n\n\nThis function allows the user to query the PUMS API with their own inputs.\nThe user can change the year of survey, the numeric and categorical variables retrieved, and the geography level.\nExample Usage:\n# Default Arguments\nquery_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP'),\n  cat_vars = 'SEX',\n  geo_level = 'State',\n  subset = '18'\n)\nNote: it is not recommended to call query_pums() without sub-setting the geography level unless necessary. This will be time-consuming due to the size of the census data sets.\n# Specifying a geography level and subset\nquery_pums(\n  geo_level = 'State',\n  subset = '37'\n)\n\n# Specifying multiple geography levels\nquery_pums(\n  geo_level = 'Region',\n  subset = c('1', '3')\n)\n\n\n\n\n\nThis function allows users to request multiple years of survey data. One tibble containing all requested years is returned.\nExample usage:\n# Default arguments\nquery_pums_multi(\n  years = c(2019, 2021, 2022),\n  num_vars = c('AGEP', 'PWGTP'),\n  cat_vars = 'SEX',\n  geo_level = 'State',\n  subset='18'\n)\n\n\n\n\n\nThis function takes the data returned by query_pums() and returns the weighted mean and standard deviation for numeric variables, and weighted counts for categorical variables.\nThe variable ‘PWGTP’ is used as the weight.\nIf no variables are specified when calling ‘summary()’, all variables except for ‘PWGTP’ will be summarized.\nExample usage:\n# Summarize all numerical and categorical variables in the 'census' tibble\nsummary(census)\n\n# Specify variables to be summarized from the 'census' tibble\nsummary(census, num_vars = c('AGEP', 'GASP'), cat_vars = 'SEX')\n\n\n\n\n\nThis function accepts one numeric variable and one categorical variable from the data returned by query_pums() and creates a boxplot.\nExample usage:\n# Plot variables from the 'census' tibble\nplot(census, cat_var = 'SEX', num_var = 'AGEP')",
    "crumbs": [
      "Home",
      "Narrative"
    ]
  },
  {
    "objectID": "pages/narrative.html#project-components",
    "href": "pages/narrative.html#project-components",
    "title": "Narrative",
    "section": "",
    "text": "Tibble helper function:\n\nThis function takes the API request built in query_pums() and turns it into a tibble.\nExample usage:\n# after building API URL, use GET()\napi_request &lt;- GET(api_url)\n\n# Call helper function to turn query results into tibble\ndata &lt;- to_tibble(request)\n\nParse times helper function:\n\nThis function takes a string containing a range of times and returns the midpoint of those two times.\nExample: given “12:30p.m to 12:34p.m”, parse_times() will return “12:42p.m”\n\nCode look-up helper function:\n\nThis function uses the Census API variable information to look up the times associated with a given code for the JWAP and JWDP variables.\nThe function uses the year specified in query_pums() to access the variable metadata.\nThe parse_times() function is applied after looking up the codes.\nExample: given “258” for the variable “JWAP”, code_lookup() will return the string “9:40 p.m. to 9:44 p.m.”\n\n\n\n\n\nThis function allows the user to query the PUMS API with their own inputs.\nThe user can change the year of survey, the numeric and categorical variables retrieved, and the geography level.\nExample Usage:\n# Default Arguments\nquery_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP'),\n  cat_vars = 'SEX',\n  geo_level = 'State',\n  subset = '18'\n)\nNote: it is not recommended to call query_pums() without sub-setting the geography level unless necessary. This will be time-consuming due to the size of the census data sets.\n# Specifying a geography level and subset\nquery_pums(\n  geo_level = 'State',\n  subset = '37'\n)\n\n# Specifying multiple geography levels\nquery_pums(\n  geo_level = 'Region',\n  subset = c('1', '3')\n)\n\n\n\n\n\nThis function allows users to request multiple years of survey data. One tibble containing all requested years is returned.\nExample usage:\n# Default arguments\nquery_pums_multi(\n  years = c(2019, 2021, 2022),\n  num_vars = c('AGEP', 'PWGTP'),\n  cat_vars = 'SEX',\n  geo_level = 'State',\n  subset='18'\n)\n\n\n\n\n\nThis function takes the data returned by query_pums() and returns the weighted mean and standard deviation for numeric variables, and weighted counts for categorical variables.\nThe variable ‘PWGTP’ is used as the weight.\nIf no variables are specified when calling ‘summary()’, all variables except for ‘PWGTP’ will be summarized.\nExample usage:\n# Summarize all numerical and categorical variables in the 'census' tibble\nsummary(census)\n\n# Specify variables to be summarized from the 'census' tibble\nsummary(census, num_vars = c('AGEP', 'GASP'), cat_vars = 'SEX')\n\n\n\n\n\nThis function accepts one numeric variable and one categorical variable from the data returned by query_pums() and creates a boxplot.\nExample usage:\n# Plot variables from the 'census' tibble\nplot(census, cat_var = 'SEX', num_var = 'AGEP')",
    "crumbs": [
      "Home",
      "Narrative"
    ]
  }
]