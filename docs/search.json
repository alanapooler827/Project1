[
  {
    "objectID": "pages/data_processing.html",
    "href": "pages/data_processing.html",
    "title": "Data Processing",
    "section": "",
    "text": "This notebook contains several functions that will allow users to query the Census API with their own inputs, and then explore the data through summary statistics.\n\nImport necessary libraries\n\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(stringr)\nlibrary(purrr)\n\n\n\nHelper function to turn result of API call into a tibble\n\nURL_ids &lt;- \"https://api.census.gov/data/2023/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n\nnext we will load the data from the API website so that we can use it for our project\n\nid_info &lt;- httr::GET(URL_ids)\nstr(id_info, max.level = 1)\n\nList of 10\n $ url        : chr \"https://api.census.gov/data/2023/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24\"\n $ status_code: int 200\n $ headers    :List of 12\n  ..- attr(*, \"class\")= chr [1:2] \"insensitive\" \"list\"\n $ all_headers:List of 1\n $ cookies    :'data.frame':    1 obs. of  7 variables:\n $ content    : raw [1:969217] 5b 5b 22 53 ...\n $ date       : POSIXct[1:1], format: \"2025-09-30 19:41:46\"\n $ times      : Named num [1:6] 0 0.0583 0.0911 0.1626 0.3719 ...\n  ..- attr(*, \"names\")= chr [1:6] \"redirect\" \"namelookup\" \"connect\" \"pretransfer\" ...\n $ request    :List of 7\n  ..- attr(*, \"class\")= chr \"request\"\n $ handle     :Class 'curl_handle' &lt;externalptr&gt; \n - attr(*, \"class\")= chr \"response\"\n\n\nextracting the content portion because this is the data we will need to work with\n\nparsed_pums_info &lt;- fromJSON(rawToChar(id_info$content))\ncol_names &lt;- parsed_pums_info[1, ]\ndata_rows &lt;- parsed_pums_info[-1, ]\n\ncreating a tibble to view data more clearly\n\npums_info &lt;- as_tibble(data_rows)\ncolnames(pums_info) &lt;- col_names \n\ndisplaying tibble\n\npums_info\n\n# A tibble: 45,584 × 4\n   SEX   PWGTP MAR   SCHL \n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n 1 1     23    2     24   \n 2 1     36    2     24   \n 3 1     9     5     24   \n 4 2     22    2     24   \n 5 1     14    5     24   \n 6 1     13    5     24   \n 7 1     35    5     24   \n 8 2     15    3     24   \n 9 2     77    5     24   \n10 1     7     5     24   \n# ℹ 45,574 more rows\n\n\n\n\nHelper function to convert API request results to tibble\n\nto_tibble &lt;- function(request) {\n  req &lt;- fromJSON(rawToChar(request$content))\n\n  # get data rows\n  data_rows &lt;- req[-1, ]\n  # create tibble\n  data &lt;- as_tibble(data_rows)\n  \n  # Assign column names to data\n  col_names &lt;- req[1, ]\n  colnames(data) &lt;- col_names \n  \n  # Return tibble\n  return(data)\n}\n\n\nHelper function to parse and convert time values\n\nparse_time &lt;- function(time_string) {\n  ts &lt;- as.character(time_string)\n  if (length(ts) == 0 || is.na(ts) || ts == \"\") return(NA)\n  \n  # split start and end\n  parts &lt;- str_split(ts, \" to \", simplify = TRUE)\n  \n  # Replace a.m/p.m with AM/PM to work with POSIXct\n  start_clean &lt;- toupper(sub(\"p.m.\", \"PM\", sub(\"a.m.\", \"AM\", parts[1])))\n  end_clean   &lt;- toupper(sub(\"p.m.\", \"PM\", sub(\"a.m.\", \"AM\", parts[2])))\n  \n  # find start and end times\n  start &lt;- as.POSIXct(start_clean, format = \"%I:%M %p\", tz = \"UTC\")\n  end   &lt;- as.POSIXct(end_clean,   format = \"%I:%M %p\", tz = \"UTC\")\n  \n  # find midpoint between start and end times\n  mid &lt;- start + difftime(end, start, units = \"secs\") / 2\n  \n  # format as HH:MM\n  format(mid, \"%I:%M %p\")\n}\n\n\n\nHelper function to map JWAP and JWDP time codes to actual times\n\ncode_lookup &lt;- function(data, var, year, parse_fun) {\n  if (var %in% names(data)) {\n    # get metadata and decode codes to value strings\n    meta &lt;- fromJSON(paste0(\"https://api.census.gov/data/\", \n                            year, \"/acs/acs1/pums/variables/\",\n                            var, \".json\"))\n    \n    lookup &lt;- meta$values$item\n\n    # pad codes with leading zeros to match lookup keys (3 digits)\n    padded_codes &lt;- str_pad(data[[var]], width = 3, side = \"left\", pad = \"0\")\n    data[[var]] &lt;- lookup[padded_codes]\n\n    # parse value strings\n    data[[var]] &lt;- sapply(data[[var]], parse_fun)\n  }\n  return(data)\n}\n\n\n\n\nFunction to query the census API with user input\n\nquery_pums &lt;- function(\n    year = 2022,\n    num_vars = c('AGEP', 'PWGTP'),\n    cat_vars = 'SEX',\n    geo_level = 'All',\n    subset = NULL\n) {\n  \n  # Stop if year is not between 2010 and 2022\n  if (!year %in% 2010:2022)\n    stop('Year must be between 2010 and 2022.')\n  \n  # Define valid numeric variables\n  valid_num &lt;- c('AGEP', 'PWGTP', 'GASP', 'GRPIP', 'JWAP', 'JWDP', 'JWMNP')\n  \n  # Stop if num_vars input is valid\n  if (!all(num_vars %in% valid_num))\n    stop('Invalid input for numeric variables.')\n  # Stop if PWGTP is not returned\n  if (!'PWGTP' %in% num_vars)\n    stop('PWGTP must be returned.')\n  # Stop if less than 2 numeric variables are returned\n  if (length(num_vars) &lt; 2)\n    stop('At least one numeric variable aside from PWGTP must be returned.')\n  \n  # Define valid categorical variables\n  valid_cat &lt;- c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX')\n  \n  # Stop if cat_vars input is invalid\n  if (!all(cat_vars %in% valid_cat))\n    stop('Invalid input for categorical variables.')\n  # Stop if no categorical variables are returned\n  if (length(cat_vars) &lt; 1)\n    stop('At least one categorical variable must be returned.')\n  \n  # Turn FER, HHL, HISPEED, JWTRNS, SCH, SCHL,\n  \n  # Define valid inputs for geography\n  valid_geo &lt;- c('All', 'Region', 'Division', 'State')\n  \n  # Stop if geo_level input is not valid\n  if (!geo_level %in% valid_geo)\n    stop('Invalid input for geography level.')\n  \n  # Base URL\n  url &lt;- 'https://api.census.gov/data'\n  # Data set we want to query\n  dataset &lt;- 'acs/acs1/pums'\n  # Variables to query\n  vars &lt;- c(num_vars, cat_vars)\n  \n  # Build URL with user inputs\n  api_url &lt;- paste0(\n    url, \"/\", year, \"/\", dataset,\n    \"?get=\", paste(vars, collapse = \",\")\n  )\n  \n  # Geography level subsetting\n  geo_map &lt;- c(\n    Region   = \"region:*\",\n    Division = \"division:*\",\n    State    = \"state:*\"\n  )\n  \n  # allow users to specify subsets of geography level\n  if (!is.null(subset)) {\n    if (geo_level == 'State') {\n      api_url &lt;- paste0(api_url, '&for=state:', paste(subset, collapse = ','))\n    }\n    if (geo_level == 'Region') {\n      api_url &lt;- paste0(api_url, '&for=region:', paste(subset, collapse = ','))\n    }\n    if (geo_level == 'Division') {\n      api_url &lt;- paste0(api_url, '&for=division:', paste(subset, collapse = ','))\n    }\n  } else if (geo_level != 'All') {\n    api_url &lt;- paste0(api_url, '&for=', geo_map[[geo_level]])\n  }\n  \n  # Query the API\n  request &lt;- GET(api_url)\n  \n  # Call helper function to turn query results into tibble\n  data &lt;- to_tibble(request)\n  \n  # Convert categorical variables to factors\n  for (var in cat_vars) {\n    if (var %in% names(data)) {\n      data[[var]] &lt;- as.factor(data[[var]])\n    }\n  }\n  \n  # Parse time variables if included in query\n  data &lt;- code_lookup(data, \"JWDP\", year, parse_time)\n  data &lt;- code_lookup(data, \"JWAP\", year, parse_time)\n  \n  # For summary function\n  class(data) &lt;- c(\"census\", class(data))\n  \n  return(data)\n}\n\n\nTest query_pums() function\nWithout sub-setting the geography level, this function is time consuming to run.\n\nquery_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP', 'JWAP'),\n  cat_vars = c('SEX', 'HISPEED'),\n  geo_level = 'State',\n  subset='06'\n)\n\n# A tibble: 391,171 × 6\n   AGEP  PWGTP JWAP     SEX   HISPEED state\n   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;    &lt;fct&gt; &lt;fct&gt;   &lt;chr&gt;\n 1 56    14    &lt;NA&gt;     2     0       06   \n 2 52    27    &lt;NA&gt;     1     0       06   \n 3 61    70    &lt;NA&gt;     1     0       06   \n 4 26    22    12:17 PM 2     0       06   \n 5 38    8     &lt;NA&gt;     2     0       06   \n 6 23    49    06:37 AM 1     0       06   \n 7 20    63    &lt;NA&gt;     1     0       06   \n 8 79    14    &lt;NA&gt;     2     0       06   \n 9 20    49    08:12 PM 2     0       06   \n10 43    47    &lt;NA&gt;     1     0       06   \n# ℹ 391,161 more rows\n\n\n\n\n\nAdd function to specify multiple years of survey data\n\nquery_pums_multi &lt;- function(\n  years,\n  num_vars = c(\"AGEP\", \"PWGTP\"),\n  cat_vars = \"SEX\",\n  geo_level = \"All\",\n  subset = NULL\n) {\n# stop if year input is invalid\nif (!all(years %in% 2010:2022))\n  stop(\"Please enter a year that is between 2010 and 2022.\")\n\n# allows user to specify multiple years of survey data\npurrr::map_dfr(\nyears,\n~ {\n  dat &lt;- query_pums(\n  year = .x,\n  num_vars = num_vars,\n  cat_vars = cat_vars,\n  geo_level = geo_level, \n  subset = subset,\n  )\n  dat$year &lt;- .x\n  dat\n  }\n  )\n}\n\n\n\nSummary function\n\n\nData investigation",
    "crumbs": [
      "Home",
      "Data Processing"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Project Overview",
    "section": "",
    "text": "Overview: Description of workflow and functions\nData Processing: Functions to query API and summarize data",
    "crumbs": [
      "Home",
      "Project Overview"
    ]
  },
  {
    "objectID": "index.html#project-goal",
    "href": "index.html#project-goal",
    "title": "Project Overview",
    "section": "Project Goal",
    "text": "Project Goal\nThe goal of this project is to write functions that will manipulate and process data sets that come from a census API. We have created generic functions to automatically summarize and plot certain returned data.",
    "crumbs": [
      "Home",
      "Project Overview"
    ]
  },
  {
    "objectID": "pages/narrative.html",
    "href": "pages/narrative.html",
    "title": "Overview",
    "section": "",
    "text": "Tibble helper function:\n\nAdd info about to_tibble helper function\nAdd example usage\n\nParse times helper function:\n\nThis function takes a string containing a range of times and returns the midpoint of those two times.\nExample: given “12:30p.m to 12:34p.m”, parse_times() will return “12:42p.m”\n\nCode look-up helper function:\n\nThis function uses the Census API variable information to look up the times associated with a given code for the JWAP and JWDP variables.\nThe function uses the year specified in query_pums() to access the variable metadata.\nThe parse_times() function is applied after looking up the codes.\nExample: given “258” for the variable “JWAP”, code_lookup() will return the string “9:40 p.m. to 9:44 p.m.”\n\nQuery Census API function:\n\nThis function allows the user to query the PUMS API with their own inputs.\nThe user can change the year of survey, the numeric and categorical variables retrieved, and the geography level.\nExample Usage:\n# Default Arguments\nquery_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP'),\n  cat_vars = 'SEX',\n  geo_level = 'All',\n  subset = NULL\n)\nNote: it is not recommended to call query_pums() without sub-setting the geography level unless necessary. This will be time-consuming due to the size of the census data sets.\n# Specifying a geography level and subset\nquery_pums(\n  geo_level = 'State',\n  subset = '37'\n)\n\n# Specifying multiple geography levels\nquery_pums(\n  geo_level = 'Region',\n  subset = c('1', '3')\n)\n\nQuery Census API with multiple years function:\nGeneric summary function:",
    "crumbs": [
      "Home",
      "Overview"
    ]
  },
  {
    "objectID": "pages/narrative.html#project-components",
    "href": "pages/narrative.html#project-components",
    "title": "Overview",
    "section": "",
    "text": "Tibble helper function:\n\nAdd info about to_tibble helper function\nAdd example usage\n\nParse times helper function:\n\nThis function takes a string containing a range of times and returns the midpoint of those two times.\nExample: given “12:30p.m to 12:34p.m”, parse_times() will return “12:42p.m”\n\nCode look-up helper function:\n\nThis function uses the Census API variable information to look up the times associated with a given code for the JWAP and JWDP variables.\nThe function uses the year specified in query_pums() to access the variable metadata.\nThe parse_times() function is applied after looking up the codes.\nExample: given “258” for the variable “JWAP”, code_lookup() will return the string “9:40 p.m. to 9:44 p.m.”\n\nQuery Census API function:\n\nThis function allows the user to query the PUMS API with their own inputs.\nThe user can change the year of survey, the numeric and categorical variables retrieved, and the geography level.\nExample Usage:\n# Default Arguments\nquery_pums(\n  year = 2022,\n  num_vars = c('AGEP', 'PWGTP'),\n  cat_vars = 'SEX',\n  geo_level = 'All',\n  subset = NULL\n)\nNote: it is not recommended to call query_pums() without sub-setting the geography level unless necessary. This will be time-consuming due to the size of the census data sets.\n# Specifying a geography level and subset\nquery_pums(\n  geo_level = 'State',\n  subset = '37'\n)\n\n# Specifying multiple geography levels\nquery_pums(\n  geo_level = 'Region',\n  subset = c('1', '3')\n)\n\nQuery Census API with multiple years function:\nGeneric summary function:",
    "crumbs": [
      "Home",
      "Overview"
    ]
  }
]