---
title: "Data Processing & Investigation"
format: html
toc: TRUE
execute: 
  warning: false
  message: false
editor_options: 
  chunk_output_type: console
---

This notebook contains several functions that will allow users to query the Census API with their own inputs, and then explore the data through summary statistics. 

### Import necessary libraries

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
library(stringr)
library(purrr)
library(ggplot2)
```


### Helper function to convert API request results to tibble
```{r}
to_tibble <- function(request) {
  req <- fromJSON(rawToChar(request$content))

  # get data rows
  data_rows <- req[-1, ]
  # create tibble
  data <- as_tibble(data_rows)
  
  # Assign column names to data
  col_names <- req[1, ]
  colnames(data) <- col_names 
  
  # Return tibble
  return(data)
}
```

#### Helper function to parse and convert time values
```{r}
parse_time <- function(time_string) {
  ts <- as.character(time_string)
  if (length(ts) == 0 || is.na(ts) || ts == "") return(NA)
  
  # split start and end
  parts <- str_split(ts, " to ", simplify = TRUE)
  
  # Replace a.m/p.m with AM/PM to work with POSIXct
  start_clean <- toupper(sub("p.m.", "PM", sub("a.m.", "AM", parts[1])))
  end_clean   <- toupper(sub("p.m.", "PM", sub("a.m.", "AM", parts[2])))
  
  # find start and end times
  start <- as.POSIXct(start_clean, format = "%I:%M %p", tz = "UTC")
  end   <- as.POSIXct(end_clean,   format = "%I:%M %p", tz = "UTC")
  
  # find midpoint between start and end times
  mid <- start + difftime(end, start, units = "secs") / 2
  
  # format as HH:MM
  format(mid, "%I:%M %p")
}
```


#### Helper function to map JWAP and JWDP time codes to actual times
```{r}
time_code_lookup <- function(data, var, year, parse_fun) {
  if (var %in% names(data)) {
    # get metadata and decode codes to value strings
    meta <- fromJSON(paste0("https://api.census.gov/data/", 
                            year, "/acs/acs1/pums/variables/",
                            var, ".json"))
    
    # extract codes
    lookup <- meta$values$item

    # pad codes with leading zeros to match lookup keys (3 digits)
    padded_codes <- str_pad(data[[var]], width = 3, side = "left", pad = "0")
    data[[var]] <- lookup[padded_codes]

    # parse value strings
    data[[var]] <- sapply(data[[var]], parse_fun)
  }
  return(data)
}
```


### Function to query the census API with user input
```{r}
query_pums <- function(
    year = 2022,
    num_vars = c('AGEP', 'PWGTP'),
    cat_vars = 'SEX',
    geo_level = 'State',
    subset = '18'
) {
  
  # Stop if year is not between 2010 and 2022
  if (!year %in% 2010:2022)
    stop('Year must be between 2010 and 2022.')
  
  # stop if year = 2020
  if (year == 2020)
    stop('No data available for 2020.')
  
  # Define valid numeric variables
  valid_num <- c('AGEP', 'PWGTP', 'GASP', 'GRPIP', 'JWAP', 'JWDP', 'JWMNP')
  
  # Stop if num_vars input is valid
  if (!all(num_vars %in% valid_num))
    stop('Invalid input for numeric variables.')
  # Stop if PWGTP is not returned
  if (!'PWGTP' %in% num_vars)
    stop('PWGTP must be returned.')
  # Stop if less than 2 numeric variables are returned
  if (length(num_vars) < 2)
    stop('At least one numeric variable aside from PWGTP must be returned.')
  
  # Define valid categorical variables
  valid_cat <- c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX')
  
  # Stop if cat_vars input is invalid
  if (!all(cat_vars %in% valid_cat))
    stop('Invalid input for categorical variables.')
  # Stop if no categorical variables are returned
  if (length(cat_vars) < 1)
    stop('At least one categorical variable must be returned.')
  
  # Define valid inputs for geography
  valid_geo <- c('All', 'Region', 'Division', 'State')
  
  # Stop if geo_level input is not valid
  if (!geo_level %in% valid_geo)
    stop('Invalid input for geography level.')
  
  # Base URL
  url <- 'https://api.census.gov/data'
  # Data set we want to query
  dataset <- 'acs/acs1/pums'
  # Variables to query
  vars <- c(num_vars, cat_vars)
  
  # Build URL with user inputs
  api_url <- paste0(
    url, "/", year, "/", dataset,
    "?get=", paste(vars, collapse = ",")
  )
  
  # Geography level subsetting
  geo_map <- c(
    Region   = "region:*",
    Division = "division:*",
    State    = "state:*"
  )
  
  # allow users to specify subsets of geography level
  if (!is.null(subset)) {
    if (geo_level == 'State') {
      api_url <- paste0(api_url, '&for=state:', paste(subset, collapse = ','))
    }
    if (geo_level == 'Region') {
      api_url <- paste0(api_url, '&for=region:', paste(subset, collapse = ','))
    }
    if (geo_level == 'Division') {
      api_url <- paste0(api_url, '&for=division:', paste(subset, collapse = ','))
    }
  } else if (geo_level != 'All') {
    api_url <- paste0(api_url, '&for=', geo_map[[geo_level]])
  }
  
  # Query the API
  request <- GET(api_url)
  
  # Call helper function to turn query results into tibble
  data <- to_tibble(request)
  
  # Convert categorical variables to factors
  for (var in cat_vars) {
    if (var %in% names(data)) {
      data[[var]] <- as.factor(data[[var]])
    }
  }
  
  # Ensure numeric variables are the correct type
  for (var in num_vars) {
    if (var %in% names(data)) {
      data[[var]] <- as.numeric(data[[var]])
    }
  }
  
  # Parse time variables if included in query
  data <- time_code_lookup(data, "JWDP", year, parse_time)
  data <- time_code_lookup(data, "JWAP", year, parse_time)
  
  # For summary function
  class(data) <- c("census", class(data))
  
  return(data)
}
```

#### Test query_pums() function

Without sub-setting the geography level, this function is time consuming to run.
```{r}
query_pums(
  year = 2022,
  num_vars = c('AGEP', 'PWGTP', 'JWAP'),
  cat_vars = c('SEX', 'HISPEED'),
  geo_level = 'State',
  subset='18'
)
```

Verify that checks work correctly (commented out after testing so document can be rendered)
Calling function with invalid year (outside of valid range):
```{r}
#query_pums(year = 2008)
```

Calling function with invalid year (2020):
```{r}
#query_pums(year = 2020)
```

Calling function without 'PWGTP' variable:
```{r}
#query_pums(year = 2022, num_vars = c('AGEP', 'JWAP'))
```

Calling function without any categorical variables:
```{r}
#query_pums(year = 2022, cat_vars = NULL)
```


### Add function to specify multiple years of survey data 
```{r}
query_pums_multi <- function(
  years,
  num_vars = c("AGEP", "PWGTP"),
  cat_vars = "SEX",
  geo_level = "State",
  subset = '18'
) {
  # stop if year input is invalid
  if (!all(years %in% 2010:2022))
    stop("Please enter years that are between 2010 and 2022.")
  
  # stop if year = 2020
  if (any(years == 2020))
    stop('No data available for 2020.')

  # query each specified year of survey data
  map_dfr(
    years,
    ~ {
      dat <- query_pums(
        year = .x,
        num_vars = num_vars,
        cat_vars = cat_vars,
        geo_level = geo_level, 
        subset = subset
        )
      dat$year <- .x
      return(dat)
      }
  )
}
```

#### Test query_pums_multi() function
```{r}
data <- query_pums_multi(
  years = c(2019, 2021, 2022),
  num_vars = c('AGEP', 'PWGTP', 'JWAP'),
  cat_vars = c('SEX', 'FER'),
  geo_level = 'State',
  subset='18'
)

# check that all requested years are included in result
data |> count(year)
```


Verify that checks for invalid years work (commented out after testing so document can be rendered)
Calling function with 2020
```{r}
#query_pums_multi(years = c(2019, 2020))
```

Calling function with years outside of 2010-2022 range
```{r}
#query_pums_multi(years = c(2008, 2009))
```

 
 
### Function for Summarizing
```{r}
summary.census <- function(
    tibble = tibble,
    num_vars = NULL,
    cat_vars = NULL
) {
  
  # if no numeric variables are specified, select all except PWGTP
  if (is.null(num_vars)) {
    num_vars <- tibble |>
      # select numeric variables
      select(where(is.numeric)) |>
      # exclude PWGTP
      select(-PWGTP) |>
      names()
  }
  
  # if no categorical variables are specified, select all
  if (is.null(cat_vars)) {
    cat_vars <- tibble |>
      select(where(is.factor)) |>
      names()
  }
  
  # use PWGTP as weight
  weight <- tibble$PWGTP
  
  # numeric variables summary
  numeric <- sapply(num_vars, function(v) {
    x <- tibble[[v]]
    # calculate weighted mean and SD
    mean <- sum(x * weight, na.rm = TRUE)/sum(weight)
    sd <- sqrt(sum(x^2*weight, na.rm = TRUE)/sum(weight)-mean^2)
    # create vector of values
    c(mean = mean, sd = sd)
  })
  
  categorical <- lapply(cat_vars, function(v) {
    tibble |>
      group_by(.data[[v]]) |>
      summarise(count = sum(weight), na.rm = TRUE)
  })
  
  return(list(num_summary = numeric, cat_summary = categorical))
}
```

### Test out summary function
```{r}
census <- query_pums(
  year = 2022,
  num_vars = c('AGEP', 'PWGTP', 'GASP'),
  cat_vars = c('SEX', 'HISPEED'),
)

summary(census)

```

### Create a plot for the census class table
```{r}
plot.census <- function(
    tibble = tibble,
    num_vars = NULL,
    cat_vars = NULL
)
ggplot(tibble,
 aes(x = get(cat_var), y = get(num_var), weight = PWGTP)) +
 geom_boxplot() +
   labs(
 title = paste("Weighted Boxplot of", num_var, "by", cat_var),
 x = cat_var,
 y = num_var
)

return(census)

```

### Test out plot function
```{r}
plot(census, num_var = "AGEP", cat_var = "SEX")
```


### Data investigation