---
title: "Data Processing & Investigation"
format: html
toc: TRUE
execute: 
  warning: false
  message: false
---

This notebook contains several functions that will allow users to query the Census API with their own inputs, and then explore the data through summary statistics. 

### Import necessary libraries

```{r}
library(tidyverse)
library(httr)
library(jsonlite)
library(stringr)
library(purrr)
```


```{r}
URL_ids <- "https://api.census.gov/data/2023/acs/acs1/pums?get=SEX,PWGTP,MAR&SCHL=24"
```

next we will load the data from the API website so that we can use it for our project
```{r}
id_info <- httr::GET(URL_ids)
str(id_info, max.level = 1)
```

extracting the content portion because this is the data we will need to work with 
```{r}
parsed_pums_info <- fromJSON(rawToChar(id_info$content))
col_names <- parsed_pums_info[1, ]
data_rows <- parsed_pums_info[-1, ]
```

creating a tibble to view data more clearly
```{r}
pums_info <- as_tibble(data_rows)
colnames(pums_info) <- col_names 
```

displaying tibble
```{r}
pums_info
```

### Helper function to convert API request results to tibble
```{r}
to_tibble <- function(request) {
  req <- fromJSON(rawToChar(request$content))

  # get data rows
  data_rows <- req[-1, ]
  # create tibble
  data <- as_tibble(data_rows)
  
  # Assign column names to data
  col_names <- req[1, ]
  colnames(data) <- col_names 
  
  # Return tibble
  return(data)
}
```

#### Helper function to parse and convert time values
```{r}
parse_time <- function(time_string) {
  ts <- as.character(time_string)
  if (length(ts) == 0 || is.na(ts) || ts == "") return(NA)
  
  # split start and end
  parts <- str_split(ts, " to ", simplify = TRUE)
  
  # Replace a.m/p.m with AM/PM to work with POSIXct
  start_clean <- toupper(sub("p.m.", "PM", sub("a.m.", "AM", parts[1])))
  end_clean   <- toupper(sub("p.m.", "PM", sub("a.m.", "AM", parts[2])))
  
  # find start and end times
  start <- as.POSIXct(start_clean, format = "%I:%M %p", tz = "UTC")
  end   <- as.POSIXct(end_clean,   format = "%I:%M %p", tz = "UTC")
  
  # find midpoint between start and end times
  mid <- start + difftime(end, start, units = "secs") / 2
  
  # format as HH:MM
  format(mid, "%I:%M %p")
}
```


#### Helper function to map JWAP and JWDP time codes to actual times
```{r}
code_lookup <- function(data, var, year, parse_fun) {
  if (var %in% names(data)) {
    # get metadata and decode codes to value strings
    meta <- fromJSON(paste0("https://api.census.gov/data/", 
                            year, "/acs/acs1/pums/variables/",
                            var, ".json"))
    
    lookup <- meta$values$item

    # pad codes with leading zeros to match lookup keys (3 digits)
    padded_codes <- str_pad(data[[var]], width = 3, side = "left", pad = "0")
    data[[var]] <- lookup[padded_codes]

    # parse value strings
    data[[var]] <- sapply(data[[var]], parse_fun)
  }
  return(data)
}
```


### Function to query the census API with user input
```{r}
query_pums <- function(
    year = 2022,
    num_vars = c('AGEP', 'PWGTP'),
    cat_vars = 'SEX',
    geo_level = 'All',
    subset = NULL
) {
  
  # Stop if year is not between 2010 and 2022
  if (!year %in% 2010:2022)
    stop('Year must be between 2010 and 2022.')
  
  # Define valid numeric variables
  valid_num <- c('AGEP', 'PWGTP', 'GASP', 'GRPIP', 'JWAP', 'JWDP', 'JWMNP')
  
  # Stop if num_vars input is valid
  if (!all(num_vars %in% valid_num))
    stop('Invalid input for numeric variables.')
  # Stop if PWGTP is not returned
  if (!'PWGTP' %in% num_vars)
    stop('PWGTP must be returned.')
  # Stop if less than 2 numeric variables are returned
  if (length(num_vars) < 2)
    stop('At least one numeric variable aside from PWGTP must be returned.')
  
  # Define valid categorical variables
  valid_cat <- c('FER', 'HHL', 'HISPEED', 'JWTRNS', 'SCH', 'SCHL', 'SEX')
  
  # Stop if cat_vars input is invalid
  if (!all(cat_vars %in% valid_cat))
    stop('Invalid input for categorical variables.')
  # Stop if no categorical variables are returned
  if (length(cat_vars) < 1)
    stop('At least one categorical variable must be returned.')
  
  # Turn FER, HHL, HISPEED, JWTRNS, SCH, SCHL,
  
  # Define valid inputs for geography
  valid_geo <- c('All', 'Region', 'Division', 'State')
  
  # Stop if geo_level input is not valid
  if (!geo_level %in% valid_geo)
    stop('Invalid input for geography level.')
  
  # Base URL
  url <- 'https://api.census.gov/data'
  # Data set we want to query
  dataset <- 'acs/acs1/pums'
  # Variables to query
  vars <- c(num_vars, cat_vars)
  
  # Build URL with user inputs
  api_url <- paste0(
    url, "/", year, "/", dataset,
    "?get=", paste(vars, collapse = ",")
  )
  
  # Geography level subsetting
  geo_map <- c(
    Region   = "region:*",
    Division = "division:*",
    State    = "state:*"
  )
  
  # allow users to specify subsets of geography level
  if (!is.null(subset)) {
    if (geo_level == 'State') {
      api_url <- paste0(api_url, '&for=state:', paste(subset, collapse = ','))
    }
    if (geo_level == 'Region') {
      api_url <- paste0(api_url, '&for=region:', paste(subset, collapse = ','))
    }
    if (geo_level == 'Division') {
      api_url <- paste0(api_url, '&for=division:', paste(subset, collapse = ','))
    }
  } else if (geo_level != 'All') {
    api_url <- paste0(api_url, '&for=', geo_map[[geo_level]])
  }
  
  # Query the API
  request <- GET(api_url)
  
  # Call helper function to turn query results into tibble
  data <- to_tibble(request)
  
  # Convert categorical variables to factors
  for (var in cat_vars) {
    if (var %in% names(data)) {
      data[[var]] <- as.factor(data[[var]])
    }
  }
  
  # Parse time variables if included in query
  data <- code_lookup(data, "JWDP", year, parse_time)
  data <- code_lookup(data, "JWAP", year, parse_time)
  
  # For summary function
  class(data) <- c("census", class(data))
  
  return(data)
}
```

#### Test query_pums() function

Without sub-setting the geography level, this function is time consuming to run.
```{r}
query_pums(
  year = 2022,
  num_vars = c('AGEP', 'PWGTP', 'JWAP'),
  cat_vars = c('SEX', 'HISPEED'),
  geo_level = 'State',
  subset='06'
)
```


### Add function to specify multiple years of survey data 
```{r}
query_pums_multi <- function(
  years,
  num_vars = c("AGEP", "PWGTP"),
  cat_vars = "SEX",
  geo_level = "All",
  subset = NULL
) {
# stop if year input is invalid
if (!all(years %in% 2010:2022))
  stop("Please enter a year that is between 2010 and 2022.")

# allows user to specify multiple years of survey data
purrr::map_dfr(
years,
~ {
  dat <- query_pums(
  year = .x,
  num_vars = num_vars,
  cat_vars = cat_vars,
  geo_level = geo_level, 
  subset = subset,
  )
  dat$year <- .x
  dat
  }
  )
}

```

 

### Writing a Generic Function for Summarizing
```{r}
plot.function #what is used for a class = function
getS3method("plot", "data.frame") #what is used for class = data frame
```


### Data investigation